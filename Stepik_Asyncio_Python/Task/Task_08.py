# Для решения этой задачи вам потребуется усовершенствовать предыдущую задачу,
# добавив ещё один счётчик, и определить свое время задержки для каждого счетчика.
#
# В этой версии добавьте еще один счетчик - "Counter 3". Мы также добавили словарь delays,
# который определяет время задержки для каждого счетчика. Таким образом, каждый счетчик "тикает" с разной скоростью.
#
# Словарь max_counts хранит максимальное значение, на которое каждый счетчик должен быть инкрементирован.
#
# # Словарь с максимальными значениями для каждого счётчика
#
# max_counts = {
#     "Counter 1": 10,
#     "Counter 2": 5,
#     "Counter 3": 15
# }
# Словарь delays, который определяет время задержки для каждого счетчика.#
#
# delays = {
#     "Counter 1": 1,
#     "Counter 2": 2,
#     "Counter 3": 0.5
# }
# Это усовершенствование демонстрирует, как с помощью асинхронного программирования можно эффективно
# управлять задачами с разными скоростями выполнения и длительностями.
# Каждая корутина запускается отдельно и работает конкурентно, что позволяет управлять
# большим количеством задач в одном потоке.
#
# Таким образом, вам нужно создать программу, которая моделирует процесс "тикания"
# трех разных счётчиков с разной скоростью и частотой. Ваша программа должна эффективно использовать
# асинхронное программирование для выполнения этой задачи. Удачи!

import asyncio

counters = {"Counter 1": 0, "Counter 2": 0, "Counter 3": 0}
max_counts = {"Counter 1": 10, "Counter 2": 5, "Counter 3": 15}
delays = {"Counter 1": 1, "Counter 2": 2, "Counter 3": 0.5}


async def counter(name, time):
    while counters[name] < max_counts[name]:
        counters[name] += 1
        await asyncio.sleep(time)
        print(f'{name}: {counters[name]}')

async def main():
    tasks = []
    for k, v in zip(max_counts, delays.values()):
        task = asyncio.create_task(counter(k, v))
        tasks.append(task)
    await asyncio.gather(*tasks)

asyncio.run(main())






























