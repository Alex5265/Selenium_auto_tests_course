import asyncio


async def task(lock):
    print('Задача приобретает блокировку...')
    # Приобретаем блокировку
    await lock.acquire()

    # Генерируем исключение, симулируя ошибку
    raise Exception('Произошло что-то плохое')

    # освобождаем блокировку (сюда никогда не дойдем)
    print('Задача освобождает блокировку...')

    # Так как перед этим есть исключение, то этот код никогда не будет выполнен
    lock.release()


async def main():
    lock = asyncio.Lock()
    asyncio.create_task(task(lock))
    await asyncio.sleep(1)
    print('Основная функция приобретает блокировку...')
    # Используем метод acquire() для асинхронного приобретения блокировки
    await lock.acquire()

    # освобождаем блокировку (сюда никогда не дойдем)
    # Освобождаем блокировку методом release().
    # Но этот код не будет выполнен, так как предыдущий вызов acquire() не будет завершен, поскольку задача,
    # которая первоначально приобрела блокировку, не освободила ее из-за ошибки
    lock.release()


asyncio.run(main())