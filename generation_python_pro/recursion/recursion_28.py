# Реализуйте функцию dict_travel(), которая принимает один аргумент:
#
# nested_dicts — словарь, содержащий в качестве значений числа, строки или словари,
# которые, в свою очередь, так же содержат в качестве значений числа, строки или словари;
# вложенность может быть произвольной
# Функция должна выводить все пары ключ-значение словаря nested_dicts,
# а также значения всех его дочерних словарей. При выводе значений дочерних словарей
# необходимо перечислять имена всех ключей, начиная с верхнего уровня, разделяя их точками.
#
# Например, в словаре:
#
# {'name': 'Arthur', 'grades': {'math': 4, 'chemistry': 3}}
# значение 4 должно быть выведено в следующем формате:
#
# grades.math: 4
# Все пары ключ-значение должны быть расположены в лексикографическом порядке, каждая на отдельной строке.
#
# Примечание 1. Гарантируется, что ключами в подаваемом в функцию словаре являются строки,
# содержащие только латинские буквы в нижнем регистре.
#
# Примечание 2. Гарантируется, что ни один ключ в подаваемом в функцию словаре
# не является последовательностью других ключей. Другими словами, словарь не может иметь, например, следующий вид:
#
# {'b.c': 1, 'b': {'c': 30, 'a': 10, 'b': 20}}
# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию dict_travel(), но не код, вызывающий ее.


# собственно-подсмотренное решение.
def dict_travel(nested_dicts, string = ''):
    for k, v in sorted(nested_dicts.items()):
        if isinstance(v, dict):
            dict_travel(v, string + f'{k}.')
        if not isinstance(v, dict):
            print(f'{string + k}: {v}')




# сторонее решение от которого дух захватывает
# def dict_travel(data):
#     for k, v in sorted(data.items()):
#         if isinstance(v, dict):
#             dict_travel({f'{k}.{key}': val for key, val in v.items()})
#         else:
#             print(f'{k}: {v}')



data = {'b': {'c': 30, 'a': 10, 'b': {'d': 40, 'e': 50}}}

dict_travel(data)







