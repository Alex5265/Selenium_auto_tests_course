# Рассмотрим два списка:
#
# messages = ['Hi, Linda', 'Hi, Sam', 'How are you doing?']
#
# senders = ['Sam Fisher', 'Linda', 'Sam Fisher']
# Первый список представляет набор отправленных сообщений в некотором мессенджере,
# второй список — набор отправителей этих сообщений. Причем сообщение messages[i]
# отправлено пользователем senders[i]. Каждое сообщение представляет собой последовательность слов,
# разделенных пробелом (знаки препинания считаются частями слов).
# Количество слов — это общее число слов, отправленное пользователем.
# Обратите внимание, что каждый пользователь может отправлять более одного сообщения.
# Например, пользователь Sam Fisher отправил
# 2 слова в первом сообщении и 4 слова во втором, следовательно, его количество слов равно
# 2+4=6.
# Реализуйте функцию best_sender(), которая принимает два аргумента в следующем порядке:
# messages — список сообщений
# senders — список имен отправителей
# Функция должна определять отправителя, имеющего наибольшее количество слов,
# и возвращать его имя. Если таких отправителей несколько, следует вернуть имя того,
# чье имя больше в лексикографическом сравнении.
#
# Примечание 1. Гарантируется, что длины передаваемых в функцию списков совпадают.
#
# Примечание 2. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию best_sender(), но не код, вызывающий ее.

from collections import defaultdict

def best_sender(messages, senders):
    def_dict = defaultdict(int)

    for k, v in zip(senders, messages):
        def_dict[k] += len(v.split())

    return sorted(def_dict.items(), key=lambda x: (x[-1], x[0]), reverse=True)[0][0]




messages = ['Hi, Linda', 'Hi, Sam', 'How are you doing?']
senders = ['Sam Fisher', 'Linda', 'Sam Fisher']

print(best_sender(messages, senders))













